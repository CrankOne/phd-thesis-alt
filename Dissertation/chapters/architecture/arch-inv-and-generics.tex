\section{Архитектурные инварианты}

Архитектурный инвариант (англ. \emph{architectural contraint}
\cite{shaw-architecture-1996, bass-architecture}) --
это свойство программной архитектуры, которое должно
сохраняться независимо от изменений в деталях реализации или
развития системы. На основе требований сформулированных ранее,
выделим архитектурные инварианты предлагаемого решения:
\begin{itemize}
    \item Модульность -- отдельные компоненты должны
    быть изолированы так, чтобы можно было заменять
    один алгоритм реконструкции на другой без
    переписывания всей системы.
    \item Детерминированность обработки событий:
    алгоритм реконструкции при одинаковом входе
    всегда даёт одинаковый выход.
    \item Соответствие модели события и триггерной
    логики: структура данных события всегда отражает
    триггерное условие, по которому оно было записано.
    \item Потоковый доступ к данным: вся архитектура
    опирается на последовательную обработку событий.
    \item Независимость предметно-ориентированных
    вычислений от ядра системы -- логика физических
    расчётов (например, калибровки, аппроксимации
    треков) не должна входить в поведенческое ядро
    модели события, а реализуется через внешние алгоритмы
    и плагины.
    \item Иерархическая структура объектной модели
    события.
\end{itemize}

В качестве механизма обеспечивающего инвариантные свойства системы
рассматривают т.н. шаблоны (паттерны) проектирования~(\emph{architecture patterns}, \emph{software design patterns})~\cite{gof1994design-patterns}.
Шаблоны проектирования представляют собой не только типовые
решения, но и формализуют основные архитектурные ограничения
системы: они фиксируют допустимые способы взаимодействия
компонентов, ограничивают допустимые механизмы расширения и тем
самым обеспечивают сохранение инвариантов архитектуры при развитии
программного комплекса. Каждое применение шаблона проектирования можно
рассматривать как задание архитектурного инварианта: он ограничивает
пространство возможных реализаций, но гарантирует сохранение
устойчивых свойств системы — модульности, слабой связности, управляемости
расширений.
%Книга представляет собой первую попытку выделения и систематизации
%структур компьютерных программ в объектно-ориентированной парадигме,
%направленных на решение задач для которых вводится классификация по
%области применения (основные, структурные, порождающие, поведенческие),
%и типовым вариантам использования.

\subsection{Конвейерный шаблон}

Идея декомпозиции сложной процедуры на последовательность
обработчиков, каждый из которых действует независимо, выполняя
элементарную задачу над общей структурой данных, широко применяется
при организации сложных вычислительных систем достаточно давно.
В информатике, возникновение идеи и
связанной с ней терминологии можно отследить до архитектуры ранних
компьютеров (например, БЭСМ-6, \cite{smirnov-besm6}).

Классическим вариантом шаблона является
<<цепочка обязанностей>>~(\emph{chain of responsibility}).
В исполнении <<цепочки обязанностей>> прежде всего направлен на
разделение отправителей и получателей запросов в цепочке обработчиков,
архитектурный шаблон <<конвейер>> (\emph{pipes and filters})~\cite{Buschmann-patterns-vol1}
структурирует последовательную обработку данных посредством компонуемых
этапов. Хотя эти две концепции обобщают линейную последовательность
обработки, их мотивация различается:
в первом случае акцент сделан на делегировании управления потоком с
с явным указанием ответственности,
во втором важнейшим аспектом является преобразование потоковых данных.
Разделение ответственности удобно при формировании сложной и разветвлённой
логики приложений во время выполнения, и наиболее широкое применение шаблон
<<цепочка обязанностей>> нашёл при обработке событий графических
пользовательских интерфейсов, где часто применяется для динамического
связывания реакций компонентов приложения с событиями пользовательского
ввода.

Основная мотивация для использования шаблона <<конвейер>> по~\cite{Buschmann-patterns-vol1}:

\begin{itemize}
    \item Система должна позволять усовершенствования за счёт
    изменения последовательности обработчиков (на высоком уровне)
    \item Допускается повторное использование отдельных обработчиков
    в различных сценариях
    \item Несмежные обработчики не обмениваются информацией (т.е.
    передача элемента данных должна производиться от одного обработчика
    к другому, без пропусков)
    \item В системе предусмотрены различные источники входных данных,
    (файл, сетевое соединение, поток ввода).
    \item В системе должна быть предусмотрена возможность представления
    или хранения результатов различными способами
    \item Явное хранение промежуточных результатов для дальнейшей
    обработки не требуется для высокоуровневых операций
\end{itemize}

Следует также упомянуть полезное свойство <<Конвейера>>, рассматриваемое
в контексте параллельных
алгоритмов~\cite{Mattson2005-parallel-patterns, smirnov-besm6}:
когда индивидуальные обработчики действительно независимы, возможно
запускать их на параллельных системах.
% более толковое изложение (чем в книге на стр.103) у авторов на сайте:
%   https://www.cise.ufl.edu/research/ParallelPatterns/PatternLanguage/AlgorithmStructure/Pipeline.htm
% следует ли здесь подвести мотивацию к обобщённому алгоритму pipe-T?

С точки зрения реализации алгоритмов обработки, конвейерный шаблон
подразумевает реализацию обратной логики управления обработчиками.
Обработчик может инициировать прекращение обработки отдельного сообщения.
Этот результат выполнения обработчика соответствует
дискриминации физического события. Кроме того, обработчик может
инициировать остановку процесса перебора в целом, что соответствует,
например, задаче поиска события в наборе.

\subsection{Коллекции и идентификаторы}

Организация модели подразумевает все возможные типы
ассоциации: одиночное и множественное агрегирование и композицию, а
также отношение наследования между типами данных, и наследование от
коллекций. 

Рассматривая C++ в качестве основной целевой среды для генерации кода,
целесообразно воспользоваться контейнерами стандартной библиотеки
шаблонов для реализации коллекций, представляющими собой обобщённые
реализации коллекций.

Важным следствием выбора C++ в качестве основной среды является
предоставляемый всеми контейнерами стандартной библиотеки набора
выведенных типов, среди которых всегда присутствует идентификатор
играющий роль синтетического ключа (тип значения для последовательностей,
кортеж пары для карт и хэш-таблиц). Тогда индексирование коллекций
можно ограничить случаями с естественным ключом, что улучшает
читаемость прикладных программ и не приносит никаких накладных
расходов.

С алгоритмической точки зрения можно выделить три независимых качества,
которые нужно контролировать при задании типа коллекции по
естественному ключу.
\begin{itemize}
    \item Свойство упорядоченности по значениям естественного ключа
    в коллекции определяет эффективный алгоритм поиска в коллекции.
    \item Разряжённость значений ключа определяет, заполняет ли
    множество значений ключа в коллекции интервал значений без пропусков.
    \item Неоднозначность соответствия.  Во многих практических случаях
    естественный ключ должен ссылаться на множество элементов.
\end{itemize}

Поскольку каждое качество представлено в виде логического флага, определим
на их основе набор меток (англ \emph{tags}) которые впоследствии используются
метапрограммой выводящей тип коллекции на основе спецификации типа данных:
упорядоченность -- \emph{ordered}, разряжённость -- \emph{sparse} (от
англ. \emph{sparsedness}), неоднозначность -- \emph{ambig} (\emph{ambiguity}).

Три логических свойства образуют набор из восьми возможных комбинаций. Каждой
комбинации ставится в соответствие определённый контейнер стандартной
библиотеки шаблонов.

\begin{table}[ht]
    \centering
    \begin{tabular}{r|l}
        Метки & Контейнер STL \\ \hline
        \emph{ordered} & \texttt{vector} или \texttt{map} \\
        \emph{sparse} & \texttt{unordered\_map} \\
        \emph{ambig} & \texttt{unordered\_multimap} \\
        \emph{ordered, sparse} & \texttt{map} \\
        \emph{ordered, ambig}  & \texttt{multimap} \\
        \emph{sparse, ambig} & \texttt{unordered\_multimap} \\
        \emph{ordered, sparse, ambig} & \texttt{multimap}
    \end{tabular}
    \caption{Соответствие типов коллекций}
    \label{tab:placeholder}
\end{table}

Нужно заметить, что требования к типу данных ключа необходимо и достаточно
связаны с операциями которые он поддерживает. Помимо того, что
для любого ключа должна быть определена операция
сравнения ($a \ne b$), упорядоченные коллекции требуют
определения отношения порядка ($a < b$), неупорядоченные --
определения хэш-функции.

Задание коллекций через такую спецификацию меток позволяет
определить и обобщённую реализацию схему реляционных
таблиц.

\subsection{Шаблон подписки}

Калибровочные данные должны быть доступны как в процедурах
реконструкции событий, так и при онлайн-сопровождении
набора данных и при извлечении других калибровочных данных.
При этом источники информации могут быть различными:
результаты отдельных процедур анализа, внешние базы
данных, сетевые сервисы. В рамках выделенных сценариев
использования очевидна необходимость в архитектурном решении,
обеспечивающем доставку актуальных калибровочных данных
среди множества потребителей без жёсткой привязки этих
потребителей к источникам, что задаёт две точки
расширения -- тип калибровочной информации, который
целесообразно учесть через статический полиморфизм,
и поведение компонента при обновлении калибровочной информации.

Такая задача естественным образом решается в рамках архитектурного
шаблона <<издатель/подписчик>> (англ. \emph{publisher/subscriber}).
Его применение опосредует прямые зависимости между
модулями: компоненты, публикующие новые значения калибровок
(издатели), агностичны к конкретным потребителям (подписчиков).

Данное решение отвечает следующим архитектурным инвариантам:
\begin{itemize}
    \item Модульность. Издатели и подписчики инкапсулируют свои роли,
    взаимодействуя только через контракт интерфейса, что облегчает
    замену или расширение отдельных модулей.
    \item Поддержка потоковой модели обработки данных.
    Калибровочная информация распространяется синхронно, при получении
    события с определённым хронологическим идентификатором и
    не нарушает последовательную логику обработки потока
    событий, не нарушая детерминированности самих алгоритмов
    реконструкции.
    \item Гибкость точек расширения. Подписка на калибровочные
    данные может осуществляться произвольными модулями, включая
    вновь разработанные алгоритмы, без изменения ядра системы.
    \item Независимость предметно-ориентированных вычислений от
    ядра. Ядро системы агностично к конкретной логике обработки
    калибровок.
    \item Стандартизированные интерфейсы данных. События публикации
    калибровочных параметров унифицированы.
\end{itemize}

Шаблон отвечает следующим сценариям:
\begin{itemize}
    \item Источник получающий событие с хронологической меткой
    вызывает каскадное обновление всех алгоритмов реконструкции,
    подписанных на определённый тип данных.
    \item В ходе набора данных подписчики имеют актуальные
    калибровки без необходимости ручной синхронизации.
    \item Специализированные процедуры анализа могут использовать
    калибровки, подписываясь на выделенные каналы
    публикации (реализована возможность пользовательского
    переопределения калибровочных данных для подмножества компонент).
\end{itemize}

Необходимо отметить, что в практической реализации критически важно
учитывать, что между информацией различных типов существуют
зависимости. Корректное разрешение зависимостей целесообразно
реализовать на уровне ядра системы. Таким образом, при инициации
рассылки калибровочной информации, компонент <<издатель>> должен
выполнить топологическую сортировку (например, алгоритмом
Кана~\cite{kahn-tsort}).

Таким образом обеспечивается согласованность данных во всех
рассмотренных сценариях использования.
