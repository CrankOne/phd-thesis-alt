\section{Предметно-ориентированные языки}

Для решения локальных задач возникающих в узкой предметной области,
часто прибегают к конструированию т.н. предметно-ориентированных
формальных языков~(англ. \emph{domain-specific languages}, также
<<проблемно-ориентированные языки
программирования>>, \acrshort{dsl})~\cite{DSL-Fowler2011}. Такие искусственные
языки не обязательно обладают качествами присущими языкам программирования
общего назначения: они могут не обладать полнотой по Тьюрингу (язык
запросов SQL в редакции 1992 года~\cite{ISO90751992}, язык
регулярных выражений~\cite{thompson1968programming},
не иметь выразительных средств для арифметических операций или операций со
строками, абстракциями ввода-вывода и т.п. Взамен такие языки
предоставляют специализированные выразительные средства для решения узкого
класса прикладных задач посредством более компактных нотаций.

В качестве примеров таких языков в \acrshort{hep} можно привести
математическую нотацию численных функций и логических предикатов
<<TFormula>> программного окружения ROOT \cite{ROOT-framework} или язык численных
функций встраиваемый в интерпретатор GDML в~\cite{Berra2011Geant4SO}.

Создание программных инструментов для интерпретации \acrshort{dsl}
возможно при помощи автоматизированных средств, на основе
формализованной специальным образом грамматики~\cite{alfred2007compilers}.
Средства вводят следующие ограничения на уровнях лексического
разбора~(англ. \emph{lexer}) и семантического анализатора~(англ. \emph{parser}):
\begin{itemize}
    \item Лексический интерпретатор поддерживает регулярные
    грамматики (тип 3 по иерархии Хомского~\cite{chomsky1956three}),
    т.е. эквивалентные детерминированному конечному автомату. Такие грамматики
    позволяют право- или леворекуррентные определения правил, однако
    не их сочетания.
    \item Парсер поддерживает более узкий набор грамматик  LALR(1)
    (\emph{look-ahead, left-to-right}, тип 2 по иерархии Хомского) ---
    анализатор с ограниченным односимвольным упреждением на основе
    левостороннего восходящего разбора.
\end{itemize}
Эти ограничения позволяют конструировать довольно сложные
грамматики, вполне достаточные для реализации небольших \acrshort{dsl},
не требующих полной выразительной мощности контекстно-свободных
грамматик и не содержащих конструкций с неоднозначным синтаксисом
или контекстно-зависимыми правилами.
%, что актуально в языках программирования общего назначения.

Формальные описания грамматик языков и программ реализующих
примитивы исполнения вынесены в приложение~\ref{appendix:dsl-grammars}.

\subsection{Числовой идентификатор детектора и язык селекторов}

Одним из частых предусматриваемых обобщающих сценариев использования
конвейерного шаблона проектирования является применение отдельного
обработчика к выборке объектов по ключу (идентификатору детектора)
в коллекции объектов. Например, в задачах анализа и
онлайн-диагностики детектора
нужно построить гистограмму величины ассоциированной с конкретным
детектором. В другом случае -- назначить различные обработчики
разным группам детекторов. В этих случаях целесообразно предусмотреть гибкий
механизм определения подмножества посредством специализрованных
выражений.

В подобных случаях нередко прибегают к индексированию детекторов и связанных
с ними данных посредством строковых идентификаторов. Так например, в системе
сбора данных COMPASS и NA64 внутренняя номенклатура идентификаторов детекторов
построена в соответствии с грамматикой описывающей имя детектора
в форме слова <<имя>> + <<номер станции>> (см. подробнее в приложении~\ref{appendix:dsl-grammars}).

Тогда выборку детекторов можно произвести на основе
какого-нибудь \acrshort{dsl} предназначенного для поиска строкового
соответствия~--- например языка регулярных выражений или
языка поисковых шаблонов Unix~(англ. \emph{wildcard}~\cite{wildcards-mcilroy1987research}).

На практике, эта грамматика в эксперименте COMPASS носит лишь
рекомендательный характер. Сложные станции этого спектрометра, состоящие из
нескольких координатно-чувствительных плоскостей (зон, в поперечном
сечении) обуславливают необходимость дополнительного подразделения. Так, по мере
развития эксперимента COMPASS в номенклатуру его детекторов
оказались введены такие элементы как \texttt{ST03ub}, \texttt{MA01c},
\texttt{MP03MX1}, вовсе не следующие формальным правилам общим более чем
для единственной станции. Выбор станции или плоскости всё ещё можно
реализовать при помощи строковых \acrshort{dsl} -- то есть, с одной стороны это
довольно гибкий подход.

С другой стороны отсутствие формальной грамматики, во-первых
приводит к неоднозначности при выборе отдельных чувствительных элементов,
затрудняет выбор связанных с ними транзитивно (в рамках модели
события) экземпляров данных.
% нужны ли тут примеры? что если я хочу выбрать только стриповые части
% микромег без пиксельных частей?
Во-вторых, операции строкового сравнения в общем случае менее
эффективны, чем сравнение числовых идентификаторов. С учётом того,
насколько часты на практике такие запросы к объектной
модели (поиск по ключу, различные условия выборки и фильтрации),
целесообразно предусмотреть программное средство для биективного
преобразования строковых и числовых идентификаторов для перечисления
номенклатуры детекторов. При этом всё ещё возможно предусмотреть
определённую свободу в именовании, часто диктуемую ситуативным
удобством при размещении детекторов на пучке и подключении
электроники.

Большим преимуществом числовых идентификаторов является удобство
их использования в ассоциативных контейнерах на основе бинарных
деревьев поиска (в частности, красно-чёрных деревьях реализованных
в библиотеке шаблонов STL C++). Это позволяет существенно упростить
работу с объектной моделью события в C++, снабдить порядок
итерирования дополнительной семантикой, обеспечить эффективный
компромисс между быстродействием при прямых запросах по ключу
и использованием памяти. Обращения к такому контейнеру не подразумевают
вычисления хеш-сумм, символьных сравнений и др. Поиск по ключу имеет
сложность $O(\text{log}~n)$.

%В дальнейшем, в рамках работы будем ссылаться на язык и его реализацию
%его интерпретатора по имени
%<<DSuL>> (\emph{detector selection micro-language}).

\subsection{Язык запросов модели события}

Объектная модель события снабжённая рефлексией сама по себе
уже позволяет строить обобщённые обработчики в рамках конвейерного
шаблона проектирования.

Так, например, достаточно определить класс обработчика строящего
одномерную гистограмму случайной величины, параметризуемый
идентификатором ссылающимся на определённый числовой атрибут события,
чтобы реализовать возможность построения всех одномерных гистограмм
любого атрибута в событии. Таким образом, введение новых атрибутов
посредством выведения шаблонов не требует никаких дополнительных
операций со стороны разработчика для создания гистограмм вводимых новым
типом значений.

В качестве идентификатора атрибута можно использовать нотацию близкую
к принятой в C++: например, выражения \texttt{SADCHits.time} или
\texttt{APVClusters.hits.x} достаточно близки к нотации разыменования
атрибутов в C++.
%Тем не менее, такая запись во втором случае допускает
%различие в интерпретации -- неясно, какая из двух коллекций (\texttt{APVClusters}
%или \texttt{APVClusters.hits}) должна итерироваться первой.

Помимо этого, нередки случаи, когда необходимо выполнить некоторые (элементарные)
преобразования с полями события, или применить фильтрацию на уровне
атрибута с типом-коллекцией. % так, как это определено, например, в DSuL.

С этой целью в программном окружении предусмотрена интеграция с
\acrshort{dsl} предназначенным для работы с потоками организованных
иерархически
объектов с заранее известной схемой (топологией). Он поддерживает базовые
операции фильтрации и арифметики значений, однако не позволяет изменять
топологию данных (что является одним из сознательных ограничений по сравнению с
более универсальными \acrshort{dsl}, такими как SQL или GraphQL \cite{graphql-comparative}).

Основными вариантами использования языка являются:
\begin{itemize}
    \item Задание логических условий для дискриминации событий или элементов
    коллекций внутри события (таких, как кластеры или треки).
    \item Задание генераторных выражений для построения N-мерных гистограмм.
    \item Задание генераторных выражений для представления данных физических
    событий в табличном виде.
\end{itemize}
Во всех случаях, язык должен допускать арифметические вычисления,
определение новых элементов объектной модели (существующих в рамках
запроса), применение агрегатных функций над выборками.

\subsection{Описание калибровочных данных}

%В экспериментальной физике нередко возникает необходимость представления
%информации с хронологической привязкой к астрономическому времени, либо
%в соответствии с внутренней хронологической номенклатурой (например, к
%периодам набора статистики, когда конфигурация установки в достаточной степени
%неизменной). Источником таких данных могут быть как внешние измерения:
%результаты геодезической съёмки, обеспечивающие относительную геометрическую
%привязку детекторов, сведения о температуре, влажности и давлении в
%экспериментальном зале, значения токов газовых смесей в рабочих объёмах
%установки и т.д. К тому же классу относятся и данные, регистрируемые
%непосредственно подсистемами детекторов: коэффициенты масштабных
%преобразований (амплитудных и временных), пороговые значения для
%подавления фона и шумов, а также коэффициенты, определяющие шкалы
%преобразований для различных типов аналого-цифровых и цифровых
%преобразователей. В дальнейшем под калибровочной информацией будем
%понимать весь объём данных, не относящихся непосредственно к
%экспериментальной статистике, но требующих временной привязки и
%используемых в алгоритмах обработки и реконструкции.
%
%В общем случае задача управления таким набором данных, подразумевающая
%прежде всего быструю операцию поиска по хронологическому ключу, и, с
%меньшим приоритетом, -- операции вставки и удаления записей, решается при
%помощи реляционных таблиц организованных под управлением различных СУБД.
%
%При этом задача интеграции СУБД с программами обработки, в особенности
%на ранних этапах разработки и прототипирования, нередко представляет
%определённую техническую сложность из-за необходимости сопровождения
%участков программы отвечающих за преобразование табличных данных в массивы
%записей (экземпляры объектной модели), разрешение коллизий, сопряжение
%информации из различных таблиц.
%
%С целью упростить процедуру ранней разработки и предоставить инструмент
%облегчающий дальнейший перенос калибровочной информации под управление
%СУБД, было разработано программное решение опирающееся на представление
%калибровочной информации в виде текстовых таблиц.
В общем, под \emph{калибровочной информацией} в данной работе понимается
совокупность данных, не относящихся непосредственно к событиям, но
требующих временной привязки и необходимых для алгоритмов обработки и
реконструкции. К такому классу относятся, например, результаты геодезических
измерений, обеспечивающие относительное позиционирование детекторов,
сведения о внешних условиях (температура, влажность, давление, параметры
газовых смесей), а также коэффициенты и пороговые значения, определяемые
по показаниям самих детекторов и задающие масштабные шкалы
измерительных каналов.

На уровне отдельных обработчиков работа с калибровочной информацией
ограничена задачей быстрого поиска по временным ключам.
Традиционно такая задача решается с
использованием реляционных таблиц под управлением \acrshort{dbms}.
Однако на стадии прототипирования интеграция с \acrshort{dbms}
может быть затруднена необходимостью преобразования табличных структур в объекты,
согласования информации из разных таблиц и обработки коллизий.

С целью упростить эти процедуры на ранних этапах разработки и
обеспечить возможность последующего переноса данных в полноценные
\acrshort{dbms} было реализовано программное решение, основанное на
представлении калибровочной информации в виде текстовых таблиц.
%Программное решение представлено библиотекой шаблонных процедур,
%работающих с индексом временных интервалов которым в соответствие
%поставлены записи состоящие из идентификатора артефакта и типа
%данных.
Решение предоставляется в виде библиотеки шаблонных
процедур, работающих с индексом временных интервалов. Интервалам
в индексе сопоставляются записи, включающие идентификатор
артефакта-источника и соответствующий тип данных.

%Индекс представляет собой шаблонный класс
%параметризуемый произвольным типом ключа для которого посредством
%шаблонной специализации C++ задаются операция сравнения и нулевой
%элемент соответствующий открытому интервалу.
Индекс построен как шаблонный класс, параметризуемый произвольным
типом ключа. Для этого ключа посредством специализации шаблонного
класса C++ задаётся единственная операции сравнения, а также определяется
нулевой элемент, интерпретируемый как открытый интервал.

Библиотека предоставляет реализации процедур для рекурсивного
разбора текстовых файлов с табличной информацией и преобразования
её в пользовательские типы данных (посредством шаблонной
специализации). Подразумевается, что документы помимо таблиц могут
содержать разметку (метаданные) влияющую на
лексическое преобразование. Так важным практическим вариантом
использования  является переопределение отдельных элементов для
временных подинтервалов, определение неполных данных, фрагментация
таблиц с целью более гибкой настройки логики применения данных,
поддержка арифметических преобразований (встроенный интерпретатор
формул) и т.д.
Библиотека содержит средства для рекурсивного разбора текстовых файлов
с табличными данными и их преобразования в пользовательские типы
(через механизмы статического полиморфизма). Предполагается,
что документы могут включать не только таблицы, но и метаданные,
аннотирующие калибровочную информацию и влияющие на процесс
лексического анализа. На практике это позволяет реализовывать
такие сценарии, как переопределение отдельных элементов для
временных подинтервалов, задание неполных данных, фрагментация
таблиц.

Лексический разбор документов организован на основе регулярных
выражений с настраиваемой грамматикой, которая описывает
искусственный язык разметки, подобный
языку описания гипертекстовых документов HTML~\cite{berners1989information},
языку спецификации каскадных стилевых таблиц CSS~\cite{lie1996cascading}),
или языку конфигурационных файлов YAML~\cite{yaml-rfc9512}.
Лексический разбор также включает интерпретатор
арифметических выражений для выполнения арифметических
преобразований (делегируется \texttt{TFormula}~\cite{ROOT-framework}).
Пользовательский код
может изменять разделители табличной разметки, способы
интерпретации и маркеры метаданных, учитывать информацию
о путях размещения артефактов.

Решение оптимизировано под цикл разработки подразумевающий
управление калибровочными размещёнными в файлах или иных артефактах
с иерархической моделью доступа, с последующей синхронизацией
сетевым сервисом настроенным на автоматическое
отслеживание ресурса на котором публикуются документы.

%В заключении нужно отметить, что хотя преобразование таблиц на этапе
%индексации артефактов не выполняется (таблицы интерпретируются только при запросе
%по ключу), необходимость построения индекса является
%естественным ограничением такой архитектуры.
Следует отметить, что преобразование таблиц в процессе индексации
не выполняется: они интерпретируются лишь при обращении по ключу.
Это обеспечивает заявленную сценарную гибкость, однако сама необходимость
построения индекса выступает архитектурным ограничением предложенного
подхода.