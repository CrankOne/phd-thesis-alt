\chapter{Искусственные грамматики}
\label{appendix:dsl-grammars}

Грамматики формулируются в форме Бэкуса-Наура~\cite{backusNaurAlgol1963revised}.

\section{Язык имён детекторов COMPASS}

В COMPASS DAQ в основном имена детекторов сформулированы,
согласно следующей грамматике:

\begin{verbatim}
    det ID ::= <detector kin> <station number>
    
    detector kin ::= <буква> | <detector kin> <буква>
    
    station number ::= <цифра> | <station number> <цифра>
\end{verbatim}
где \texttt{<буква>} и \texttt{<цифра>} --- терминалы грамматики.

Примерами грамматически корректных имён детекторов в такой простейшей
грамматике являются \texttt{ECAL0} (калориметр ECAL), \texttt{HCAL3}
(третий модуль адронного калориметра), \texttt{MM03} и т.д.

\section{Язык селекторов}

В качестве альтернативы строковым \acrshort{dsl}, для фильтрации записей
по числовым идентификаторам предложена следующая грамматика:
\begin{verbatim}
    selExpr ::= <ftCompExpr>
            | ( <selExpr> )
            | ! <selExpr>
            | <selExpr> && <selExpr>
            | <selExpr> || <selExpr>
            | <selExpr> ^^ <selExpr>
            
 ftCompExpr ::= <id> cmpOp <id>
 
      cmpOp ::= > | >= | < | <= | == | != 
\end{verbatim}
где терминалом грамматики \texttt{id} выступает определяемый на этапе
лексического анализа числовой литерал, либо идентификатор. Набор
идентификаторов определяется динамически во времени выполнения, и
подобная простая грамматика позволяет создать LALR(1)-парсер для
задания выражений-фильтров (\emph{селекторов}), сформулированных
в C-подобном синтаксисе бинарных логических операторов и операторов
сравнения, и учитывающих иерархию детекторов установки (посредством
идентификаторов <<\texttt{kin}>>, <<\texttt{number}>>,
<<\texttt{xIdx}>>, <<\texttt{wireID}>> и прочих, зависящих от топологии
чувствительных элементов детектора). Рассмотрим следующие примеры:

\begin{itemize}
    \item Выбрать ячейку $2\times3$ основной части
    ECAL:
    
    \texttt{kin == ECAL \&\& xIdx == 2 \&\& yIdx == 3 \&\& zIdx == 1}

    \item Выбрать все модули HCAL за исключением нулевого:

    \texttt{kin == HCAL \&\& number != 0}

    \item Выбрать станции MM №1, 2, 3 или GM №5:

    \texttt{kin==MM \&\& (number>0 \&\& number<4) || (kin==GM \&\& 5==number)}
\end{itemize}

Хотя выбранная нотация бинарных операторов несколько избыточна, она
близка к нотации принятой в языке С, понятна и привычна пользователю.

В качестве самостоятельного программного компонента, интерпретатор языка
селекторов применяются для спецификации отдельным обработчикам конкретного
набора детекторов (или, в соответствие с моделью события -- показаний их
отдельных чувствительных элементов, зарядов и временных кластеров,
интегральных величин).

В качестве модели выполнения выбрано бинарное дерево операций с функциями
обратного вызова. Ввиду простоты семантики языка, промежуточное
представление и оптимизации избыточны.

\section{Язык запросов HDQL}

Поскольку данный \acrshort{dsl} во всех случаях порождает вычислитель в виде
генераторного выражения (частным случаем которого является логическое значение),
модель языка предполагает наличие единственного корневого элемента.
Этот элемент обычно считывается из потокового источника. Таким образом
сценариям использования отвечает модель последовательного
перебора~(\emph{scan}) --- в отличие от выборок на индексированных
данных применяемых в СУБД.

Язык вводит следующие абстракции:
\begin{itemize}
    \item \emph{Типом данных} $t \in T$ называется набор рефлексивной
    информации о некотором адресе памяти. При этом, всё множество
    типов данных $T$ в языке разделяется на подмножество
    \emph{атомарных} и \emph{составных} типов данных $T = T_a \cup T_c$,
    различных по составу этой рефлексивной информации.
    \item Для \emph{атомарных типов} данных (\emph{atomic}) $t_a \in T_a$ запись
    содержит только код-идентификатор, доступный для внешних приложений.
    \item \emph{Составным типом данных} (\emph{compound}) $T_c$ является
    именованный набор \emph{определений атрибутов}.
    \item \emph{Определением атрибута} (\emph{attribute definition}) является
    именованное отношение ассоциации $r \in R$ между двумя экземплярами данных,
    заданное в виде кортежа значений состоящего из
    типа данных $t \in T$, множественности $m$ (в смысле скалярного значения или
    индексированной коллекции), и операций доступа $a \in A$: $r = (t,m,a)$.
    \item Любая коллекция поддерживает индексирование по ключу. При этом
    рассматриваемый \acrshort{dsl} не включает грамматики описывающие выбор
    элементов коллекции (делегирование реализуется через интеграцию
    посредством выделенного интерфейса).
    \item Элементарным \emph{запросом} является указание определения атрибута $r$, которое
    необходимо учесть для извлечения данных из составного типа. При этом,
    если атрибут ссылается на коллекцию, к запросу возможно присоединить
    предикаты выбора (по ключу) или фильтрации (по значению). Выполнением
    запроса таким образом является выполнение процедуры указанной в
    интерфейсе $m$ записи $r$ с учётом выражений выбора и фильтрации.
    Результатом выполнения запроса является последовательность адресов в памяти,
    соответствующая определению атрибута и ключе, соответствующему
    взятому элементу коллекций, если разыменование определения атрибута
    использует коллекцию.
    \item Элементарные запросы возможно определять в последовательности, образуя
    таким образом составные запросы. Рекурсивное выполнение также имеет
    результатом последовательность адресов в памяти, аннотированных кортежем
    ключей, соответствующим последовательности разыменования в коллекциях.
\end{itemize}

Таким образом, интеграция с пользовательской объектной моделью требует задания
множества составных типов данных $T_c$ на основе атомарных типов данных $T_a$ через
набор кортежей $r$ выражающих именованные отношения между составными типами данных,
в конечном счёте всегда реализующихся через атомарные типы. Следует заметить, что
в такой формулировке язык не предполагает какой-то определённой локализации данных
составных типов в памяти. Всё взаимодействие с составными данными осуществляется посредством
абстрактных интерфейсов реализованных в $T_{a,c}$ и $m$. Поскольку модель выполнения
запросов опирается на проход в глубину, а интерфейс обращения к коллекции предполагает
только операции с последовательным итератором поддерживающим только единичный инкремент,
реализации интерфейсов могут генерировать данные динамически (разыменование
атрибутов и итерирование коллекций неидемпотентны).
Реализации интерфейсов могут запрашивать данные из внешних ресурсов (файлов, баз данных).
В частном случае определение атрибута может ссылаться на поля структур и классов C/C++,
включая коллекции (списки, различные ассоциативные массивы).

Важным архитектурным решением является поддержка рекурсивного определения составного
типа (возможно задание циклических отношений). Хотя рекурсия существенно усложняет
реализацию алгоритмов в рассмотренных
вариантах использования, рекурсивные модели важны практически. Например,
при задании объектной модели трека частицы, используется абстракция вероятной
точки взаимодействия частицы с рабочим веществом детектора (чувствительным
элементом) выраженная в виде пространственных координат и матрицы ковариации.
Для задачи поиска и отбора кандидатов для треков частицы удобно
применять рекуррентное определение такого типа, поскольку нередки события в
которых сработали не все плоскости стрипового детектора, и алгоритм
реконструкции трека должен, вообще говоря, рассмотреть все комбинации. В
составных детекторах имеет смысл рассматривать временные кластеры
определённые через временные кластеры в отдельных элементах и т.д.
Хотя алгоритм обхода модели запроса, в принципе, позволяет конструировать рекуррентные
запросы (программными средствами), сознательным ограничением грамматики
языка является невозможность такой запрос сформулировать.

Язык имеет следующую грамматику (приводится с сокращениями):

\begin{verbatim}
     aQExpr ::= <aOp>
            | <aQExpr> <бинарный оператор> <aQExpr>
            | <унарный оператор> <aQExpr>
            | ( <aQExpr> )
            | <идентификатор> ( <argsList> )

   argsList ::= <aQExpr> | <argsList> , <aQExpr>

        aOp ::= <числовой литерал> | <queryExpr>

  selection ::= <выражение с ключом>
            | <выражение с ключом> -> <метка ключа>
            | -> <метка ключа>

  queryExpr ::= . <идентификатор>
            | . <идентификатор> selection
            | queryExpr . <идентификатор>
            | queryExpr . <идентификатор> <selection>
            | queryExpr { <scopedDefs> }

scopedDefs ::= <vCompoundDef>
           | <vCompoundDef> : <aQExpr>
           | : <aQExpr>

vCompoundDef ::= <идентификатор> := aQExpr 
            | <vCompoundDef> , <идентификатор> := <aQExpr>
\end{verbatim}

Здесь терминалы \texttt{<бинарный оператор>} и \texttt{унарный оператор}
включают лексемы основных арифметических и логических операций, включая битовые
операции. % Эти операции применимы только к результатам запросов атомарных типов.

Лексема \texttt{<выражение с ключом>} % и \texttt{<ключи>}
выделяется на этапе лексического анализа с целью делегирования внешнему
интерпретатору произвольного языка селекторов (в частности, DSuL).
С этой целью для селекторов коллекций предусмотрен специальный интерфейс.
Посредством разделителя \texttt{->} с определённым запросом может задаваться
идентификатор ключа \texttt{<метка ключа>}, необходимый во внешних
приложениях для именования критической части ключа записи.

Словарь лексем \texttt{<идентификатор>} статический, отвечает множеству
определений атрибутов $r$, формируется на основе рефлексивной информации об
иерархии данных (в контексте работы --- на основе объектной модели физического
события).

Рассмотрим примеры в контексте модели физического события.

Корневые объекты независимы и поступают
на вход выражения последовательно. Извлечение значений атрибута
(например, временной метки --- \texttt{eventTimestamp} из каждого события
выражается следующим образом:

\begin{verbatim}
    .eventTimestamp
\end{verbatim}

Корневой объект, как правило, содержит вложенные коллекции. К
атрибутам элементов этих коллекций можно обращаться, используя
оператор <<\texttt{.}>> последовательно:
\begin{verbatim}
    .hits.energyDeposition
\end{verbatim}
такой запрос вернёт значения \texttt{energyDeposition} для всех
элементов коллекции \texttt{hits} корневого объекта.

Во многих практических случаях коллекции индексированы и представляют
инъективные отображения $(\text{ключ} \rightarrow \text{значение})$.
Например, линейный массив -- это упорядоченная коллекция,
где каждый элемент имеет числовой индекс, и доступ к отдельному
элементу возможен с помощью оператора <<\texttt{[]}>> (лексема \texttt{ключи}):
\begin{verbatim}
    .hits[23].energyDeposition
\end{verbatim}
возвращает значение \texttt{energyDeposition}
для 23-его элемента массива \texttt{hits}.

%Грамматикой предусмотрены арифметические операции для изменения значений,
%например выражение:
%\begin{verbatim}
%    .hits.energyDeposition *= 100
%\end{verbatim}
%умножит и перезапишет значения в атрибуте \texttt{energyDeposition}, во всех
%элементах коллекции \texttt{hits} корневого элемента.

Выражения внутри оператора <<\texttt{[]}>> (лексема \texttt{<выражение с ключом>})
могут использовать произвольную грамматику, предоставляемую
пользовательским окружением. Например, выражение с использованием DSuL:
\begin{verbatim}
    .hits[kin == ECAL].energyDeposition
\end{verbatim}
соответствует модификации всех элементов коллекции \texttt{hits}
корневого элемента для которых ключи адресуют элементы принадлежащие
электромагнитному калориметру ECAL.

Все запросы возвращают векторизованный результат (упорядоченный набор
значений или составных объектов), которые затем, в рамках одного события,
итерируются пользовательским кодом (обработчика). Можно создавать или изменять
типы составных объектов в пределах запроса (сама объектная модель события
имеет статическую схему) посредством оператора <<\texttt{:=}>> определяющего
новые (синтетические) атрибуты внутри оператора области видимости
определённого как фигурные скобки <<\texttt{\{\}}>>. Здесь применяется
грамматическое правило \texttt{<vCompoundDef>}. Выражение
\begin{verbatim}
    .hits{halfDistance := .distance / 2}
\end{verbatim}
возвратит таблицу, в которой каждый элемент коллекции \texttt{hits}
расширен новым атрибутом \texttt{halfDistance}, вычисленным как
половина атрибута \texttt{distance}.

Возможно применение фильтрации на основе значений атрибутов (вдобавок
к выборке по ключу). Для этого логическое
выражение помещается внутрь оператора области видимости после
разделителя <<\texttt{:}>> -- применяется
грамматическое правило \texttt{<scopedDefs>}. Выражение
\begin{verbatim}
    .hits{: .energyDeposition > 10}
\end{verbatim}
возвратит таблицу содержащую элементы коллекции \texttt{hits}
со значением атрибута \texttt{energyDeposition} превышающим 10.

Оператор <<\texttt{:}>> введён с тем чтобы можно было разделить
фильтр по значению и создание новых атрибутов. Например, выражение
\begin{verbatim}
    .tracks{chi2ToNDF := .chi2/.ndf : .chi2ToNDF < 10}
            .hits[kin == MM || kin == GM]
\end{verbatim}
возвратит таблицу набранную из треков со значением синтетического
атрибута \texttt{chi2ToNDF} более десяти в детекторах MM и GM.

На выборках сформированных посредством описанных выразительных средств
грамматика языка предусматривает различные агрегатные методы, такие как
отыскание максимумов и минимумов, суммирование, составление набора уникальных
элементов, взятие произвольного элемента и т.д.

Предложенный язык (HDQL, Hierarchical Data Query Language) представляет
собой специализированный язык запросов, разработанный для формального
и эффективного доступа к иерархически организованным данным в средах
C и C++. Язык решает проблему быстрого создания запросов для проверки
логических условий и построения гистограмм.

%Он опирается на
%концепцию определений атрибутов
%(Attribute Definitions, AD), которые описывают структуру
%данных (арность: скаляр/коллекция, тип: атомарный/составной)
%и связываются с интерфейсами, реализующими доступ к значениям.

%Запросы в HDQL трактуются как генераторы состояний, поддерживающие
%последовательный перебор вложенных атрибутов, выбор подмножеств
%коллекций и фильтрацию по значениям. Поддерживается динамическое
%определение временных атрибутов, позволяющее формировать производные
%характеристики прямо в выражении запроса. Результатом выполнения
%запроса служит как само значение, так и связанный с ним ключ,
%идентифицирующий положение результата в структуре исходных данных.

C точки зрения \acrshort{api} HDQL предоставляет механизмы компиляции и
исполнения запросов с минимальными накладными расходами и строгой типовой
согласованностью, не являясь в то же время обязательным компонентом
рассматриваемого программного окружения. Доступ к данным осуществляется
через абстрактные
дескрипторы, а разрешение ключей -- через плоское представление,
удобное для анализа. Язык ориентирован на потоковую обработку
событий, типичную для экспериментов в физике высоких энергий,
где необходима эффективная работа с глубокой иерархией
структур данных.